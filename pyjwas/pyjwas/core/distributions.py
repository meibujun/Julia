import numpy as np
from scipy.stats import norm, invgamma, chi2, t
from typing import Union, Tuple

# This module will provide distribution-related functions.
# Many will be wrappers around scipy.stats or numpy.random for convenience
# or to implement specific parameterizations used in JWAS.jl if they differ.

# --- Normal Distribution ---
def sample_normal(mean: float = 0.0, std_dev: float = 1.0, size: Union[int, Tuple[int, ...]] = 1) -> Union[float, np.ndarray]:
    """Samples from a Normal distribution."""
    if std_dev < 0:
        raise ValueError("Standard deviation cannot be negative.")
    return np.random.normal(loc=mean, scale=std_dev, size=size)

def logpdf_normal(x: Union[float, np.ndarray], mean: float = 0.0, std_dev: float = 1.0) -> Union[float, np.ndarray]:
    """Log PDF of the Normal distribution."""
    if std_dev <= 0:
        # scipy.stats.norm.logpdf handles std_dev=0 by returning -inf or nan, which is often fine.
        # Depending on strictness, could raise ValueError for std_dev <= 0.
        pass
    return norm.logpdf(x, loc=mean, scale=std_dev)

# --- Inverse Gamma Distribution ---
# scipy.stats.invgamma uses shape (a) and scale (loc=0, scale=b)
# Often parameterized in Bayesian stats with shape (alpha) and rate (beta) or scale (beta)
# If JWAS.jl uses shape/rate (alpha, beta), then scipy's scale parameter is beta.
def sample_invgamma(shape: float, scale: float, size: Union[int, Tuple[int, ...]] = 1) -> Union[float, np.ndarray]:
    """
    Samples from an Inverse Gamma distribution.
    Args:
        shape (alpha): Shape parameter.
        scale (beta): Scale parameter. (This corresponds to scipy's 'scale' parameter)
        size: Output shape.
    """
    if shape <= 0 or scale <= 0:
        raise ValueError("Shape and scale parameters for Inverse Gamma must be positive.")
    return invgamma.rvs(a=shape, scale=scale, size=size)

def logpdf_invgamma(x: Union[float, np.ndarray], shape: float, scale: float) -> Union[float, np.ndarray]:
    """
    Log PDF of the Inverse Gamma distribution.
    Args:
        x: Value(s) at which to evaluate the log PDF.
        shape (alpha): Shape parameter.
        scale (beta): Scale parameter.
    """
    if shape <= 0 or scale <= 0:
        # Allow invgamma.logpdf to handle x <= 0 (it returns -inf)
        pass
    return invgamma.logpdf(x, a=shape, scale=scale)

# --- Scaled Inverse Chi-squared Distribution ---
# A scaled inverse chi-squared distribution with nu degrees of freedom and scale s^2
# X ~ Inv-Chi2(nu, s^2) can be generated by:
# 1. Y ~ Chi2(nu)
# 2. X = nu * s^2 / Y
# Its mean is nu * s^2 / (nu - 2) for nu > 2.
# Its variance is 2 * (nu * s^2)^2 / ( (nu-2)^2 * (nu-4) ) for nu > 4.
# It is often used as a prior for variance parameters.
# It can also be seen as a special case of the Inverse Gamma distribution:
# Inv-Chi2(nu, s^2) is equivalent to Inv-Gamma(nu/2, nu*s^2/2).

def sample_scaled_inv_chi2(df: float, scale_sq: float, size: Union[int, Tuple[int, ...]] = 1) -> Union[float, np.ndarray]:
    """
    Samples from a Scaled Inverse Chi-squared distribution.
    X ~ Inv-Chi2(df, scale_sq)
    Equivalent to Inv-Gamma(df/2, df*scale_sq/2).
    """
    if df <= 0 or scale_sq <= 0:
        raise ValueError("Degrees of freedom (df) and squared scale (scale_sq) must be positive.")

    # Using the Inverse Gamma equivalence:
    ig_shape = df / 2.0
    ig_scale = (df * scale_sq) / 2.0
    return sample_invgamma(shape=ig_shape, scale=ig_scale, size=size)

def logpdf_scaled_inv_chi2(x: Union[float, np.ndarray], df: float, scale_sq: float) -> Union[float, np.ndarray]:
    """
    Log PDF of the Scaled Inverse Chi-squared distribution.
    X ~ Inv-Chi2(df, scale_sq)
    Equivalent to Inv-Gamma(df/2, df*s^2/2).
    """
    if df <= 0 or scale_sq <= 0:
        # Let logpdf_invgamma handle x <=0
        pass

    ig_shape = df / 2.0
    ig_scale = (df * scale_sq) / 2.0
    return logpdf_invgamma(x, shape=ig_shape, scale=ig_scale)

# --- Multivariate Normal Distribution ---
# numpy.random.multivariate_normal is available.
# scipy.stats.multivariate_normal for PDF/logPDF.

def sample_multivariate_normal(
    mean: np.ndarray,
    cov: np.ndarray,
    size: Union[int, Tuple[int, ...]] = 1 # Corrected type hint for size
) -> np.ndarray:
    """Samples from a Multivariate Normal distribution."""
    # np.random.multivariate_normal handles 1D mean vector and 2D covariance matrix
    # It can also handle 'size' argument to generate multiple samples.
    # Size in np refers to the number of samples, not dimensions of one sample.
    return np.random.multivariate_normal(mean=mean, cov=cov, size=size)

def logpdf_multivariate_normal(
    x: np.ndarray,
    mean: np.ndarray,
    cov: np.ndarray,
    allow_singular: bool = False
) -> Union[float, np.ndarray]:
    """Log PDF of the Multivariate Normal distribution."""
    # scipy.stats.multivariate_normal.logpdf handles this.
    # x can be (Ndim) or (Nsamples, Ndim)
    try:
        # Import locally to ensure it's available during execution of this function
        from scipy.stats import multivariate_normal
        return multivariate_normal.logpdf(x, mean=mean, cov=cov, allow_singular=allow_singular)
    except ImportError:
        # This block might not be strictly necessary if scipy is a core dependency
        # but serves as a fallback or clear error indication.
        raise ImportError("scipy.stats.multivariate_normal is required for logpdf_multivariate_normal but not found.")


# Other distributions like Student's t, Beta, Dirichlet, etc., can be added as needed.
# For now, focusing on those very common in Bayesian mixed models.

if __name__ == '__main__':
    print("--- Distributions Examples ---")

    # Normal
    norm_sample = sample_normal(mean=5, std_dev=2, size=3)
    print(f"Normal samples (mean=5, std=2): {norm_sample}")
    norm_logpdf_val = logpdf_normal(norm_sample, mean=5, std_dev=2)
    print(f"Log PDF of normal samples: {norm_logpdf_val}")
    print(f"Log PDF of 6 (mean=5, std=2): {logpdf_normal(6, 5, 2)}")

    # Inverse Gamma
    ig_sample = sample_invgamma(shape=3.0, scale=2.0, size=3)
    print(f"Inverse Gamma samples (shape=3, scale=2): {ig_sample}")
    ig_logpdf_val = logpdf_invgamma(ig_sample, shape=3.0, scale=2.0)
    print(f"Log PDF of IG samples: {ig_logpdf_val}")
    print(f"Log PDF of 1.0 (IG shape=3, scale=2): {logpdf_invgamma(1.0, 3.0, 2.0)}")


    # Scaled Inverse Chi-squared
    sics_sample = sample_scaled_inv_chi2(df=5.0, scale_sq=1.5, size=3)
    print(f"Scaled Inv Chi2 samples (df=5, s^2=1.5): {sics_sample}")
    sics_logpdf_val = logpdf_scaled_inv_chi2(sics_sample, df=5.0, scale_sq=1.5)
    print(f"Log PDF of SICS samples: {sics_logpdf_val}")
    print(f"Log PDF of 2.0 (SICS df=5, s^2=1.5): {logpdf_scaled_inv_chi2(2.0, 5.0, 1.5)}")

    # Multivariate Normal
    mv_mean = np.array([0, 1])
    mv_cov = np.array([[1, 0.5], [0.5, 2]])
    try:
        # from scipy.stats import multivariate_normal # Already imported locally in function
        mv_samples = sample_multivariate_normal(mean=mv_mean, cov=mv_cov, size=3)
        print(f"Multivariate Normal samples (3 samples, 2D):\n{mv_samples}")
        mv_logpdf_val = logpdf_multivariate_normal(mv_samples, mean=mv_mean, cov=mv_cov)
        print(f"Log PDF of MVN samples:\n{mv_logpdf_val}")
        single_mv_point = np.array([0.5, 1.5])
        print(f"Log PDF of point {single_mv_point} (MVN): {logpdf_multivariate_normal(single_mv_point, mv_mean, mv_cov)}")
    except ImportError as ie:
        print(f"Failed to run MVN example due to ImportError: {ie}")
    except Exception as e:
        print(f"Error in MVN example: {e}")
